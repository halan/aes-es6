<!DOCTYPE html><html lang="en"><head><title>expandKey</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="expandKey"><meta name="groc-project-path" content="src/expandKey.js"><meta name="groc-github-url" content="https://github.com/halan/aes-es6"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/halan/aes-es6/blob/master/src/expandKey.js">src/expandKey.js</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h2 id="expanso-das-chaves">Expansão das chaves</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="importaes">Importações</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Importa o passo <code>subBytes</code> que faz a substituição com a S-Box</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">import</span> subBytes <span class="hljs-keyword">from</span> <span class="hljs-string">'./steps/subBytes'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Importa xor, que recebe duas arrays de números e aplica um xor em cada elemento correspondente.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">import</span> { xor, lastWord, splitInWords } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="constante-rcon">Constante Rcon</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Constante rcon pra ser feito xor com o primeiro byte e cada word (1 word são 4 bytes)
1 rcon para cada nova chave criada, ou seja: 10 rcons.
Mais detalhes sobre o cálculo para chegar nessa constante pode ser encontrado
<a href="https://en.wikipedia.org/wiki/Rijndael_key_schedule#Rcon">aqui</a>.
O rcon[0] não é utilizado no AES, por isso decidi iniciar pelo <code>0x01</code> para simplificar o reducer
mais pra frente.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> RCON = [<span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x1b</span>, <span class="hljs-number">0x36</span>]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="-keyschedulecore-"><code>KeyScheduleCore</code></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Esta função rotaciona os bytes de um word, ex:
<code>[0, 1, 2, 3] -&gt; [1, 2, 3, 0]</code></p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> rotWord = ([first, ...rest]) =&gt; [...rest, first]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>subWord</code> é a mesma coisa que o <code>subBytes</code>. No caso da expansão de chave esse procedimento é feito
sobre uma word. Todo o procedimento de expansão de chave é baseado em words, que funcionam como
subblocos. Entretanto o <code>subBytes</code> é apenas uma substituição de um byte por outro, se aplico em 4 bytes
ou em 16 o procedimento em si não é alterado.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> subWord = subBytes</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Faz um xor no primeiro byte de uma word com rcon especificado.
Esse procedimento é feito exatamente 16 vezes, um para cada valor de rcon.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> xorFirstByte = ([first, ...rest], value) =&gt; [ value ^ first, ...rest ]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Procedimento principal da expansão de chave. Aqui aplicamos a sequência:
<code>rotWord</code>, <code>subWord</code> e por fim o <code>xor</code> no <code>rcon</code> correspondente da rodada.
Esse procedimento é aplicado sempre na primeira word de cada chave, ou seja
é aplicada tantas vezes iguais ao número de rodadas, que no noso caso são 11.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> keyScheduleCore = (word, rcon) =&gt; xorFirstByte(subWord(rotWord(word)), rcon)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><a href="https://en.wikipedia.org/wiki/Rijndael_key_schedule#Common_operations">Mais detalhes...</a></p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="gerao-das-chaves">Geração das chaves</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Separei nessa função, o procedimento de criar uma chave completa de 128 bits
a partir de uma chave anterior e um valor de rcon.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> generate = (lastKey, rcon) =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Primeiramente calculo o valor base usando <code>KeyScheduleCore</code> que vai receber a última word da chave.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> base = keyScheduleCore(lastWord(lastKey), rcon)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>divido a chave em grupos formando 4 words.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> words = splitInWords(lastKey)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Então faço um reduce em cima dessas words, ou seja, um loop de 4 iterações.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">return</span> words.reduce( (newKey, word) =&gt; (</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Em cada iteração ele monta mais uma word da chave
A primeira word é um xor com a primeira word da chave anterior e o valor base
As words seguintes é um xor com a word correspondente na chave anterior
e a última word calculado da própria chave (estou usando <code>Uint8Array</code> pra armazenar os valores)</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([...newKey, ...xor(word, newKey.length ? lastWord(newKey) : base )])
  ), [])
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Finalmente a função de expansão de chave. Ela recebe uma chave e entrega 11!</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> key =&gt; (</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Passo um reduce sobre os RCONS, e para cada RCON executo a função de geração de chave
passando como entrada a última chave e o rcon da rodada</p></div></div><div class="code"><div class="wrapper">  RCON.reduce( (keys, rcon) =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Pega a última chave</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">const</span> [last] = [...keys].reverse()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A cada rodada, gera uma nova chave e adiciona à lista de chaves</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">return</span> [...keys, generate(last, rcon)]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A chave original é entregue para o reducer como uma <code>Uint8Array</code></p></div></div><div class="code"><div class="wrapper">  }, [<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(key)] )
)</div></div></div></div></body></html>