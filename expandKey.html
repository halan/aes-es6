<!DOCTYPE html><html lang="en"><head><title>expandKey</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="expandKey"><meta name="groc-project-path" content="src/expandKey.js"><meta name="groc-github-url" content="https://github.com/halan/aes-es6"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/halan/aes-es6/blob/master/src/expandKey.js">src/expandKey.js</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h2 id="expanso-das-chaves">Expansão das chaves</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="importaes">Importações</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Importa o passo subBytes que faz a substituição com a S-Box</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">import</span> subBytes <span class="hljs-keyword">from</span> <span class="hljs-string">'./steps/subBytes'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Importa xor, que recebe duas arrays de números e aplica um xor em cada elemento correspondente.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">import</span> { xor, group } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="constantes">Constantes</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Constante rcon pra ser feito xor com o primeiro byte e cada word (1 word são 4 bytes)
1 RCON para cada nova chave criada, ou seja: 10 rcons.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> RCON = [<span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x1b</span>, <span class="hljs-number">0x36</span>]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Constante para definir o tamanho de uma chave em words:<code>4</code>
Ou seja, 16 bytes, 16 letras, 128 bits; esse é o tamanho de uma chave.
O AES foi construído para trabalhar com chaves de até 256 bits, mas decidi
não implementar a encriptação utilizando outros tamanhos de chave. Se fosse o caso,
haveria mais rodadas e portanto mais chaves e um rcon maior.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> WORDS_IN_A_KEY = <span class="hljs-number">4</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Constante pra definir o tamanho em bytes de um word: <code>4</code></p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> WORD_SIZE = <span class="hljs-number">4</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="keyschedulecore">KeyScheduleCore</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Esta função rotaciona os bytes de um word, ex:
<code>[0, 1, 2, 3] -&gt; [1, 2, 3, 0]</code></p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> rotWord = word =&gt; [...word.slice(-(WORD_SIZE-<span class="hljs-number">1</span>)), word[<span class="hljs-number">0</span>]]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>subWord é a mesma coisa que o subBytes. No caso da expansão de chave esse procedimento é feito
sobre uma word. Todo o procedimento de expansão de chave é baseado em words, que funcionam como
subblocos. Entretanto o subBytes é apenas uma substituição de um byte por outro, se aplico em 4 bytes
ou em 16 o procedimento em si não é alterado.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> subWord = subBytes</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Faz um xor no primeiro byte de uma word com rcon especificado.
Esse procedimento é feito exatamente 16 vezes, um para cada valor de rcon.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> xorFirstByte = (word, value) =&gt; [ value ^ word[<span class="hljs-number">0</span>], ...word.slice(<span class="hljs-number">1</span>) ]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Procedimento principal da expansão de chave. Aqui aplicamos a sequência:
<code>rotWord</code>, <code>subWord</code> e por fim o <code>xor</code> no <code>rcon</code> correspondente da rodada.
Esse procedimento é aplicado sempre na primeira word de cada chave, ou seja
é aplicada tantas vezes iguais ao número de rodadas, que no noso caso são 11.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> keyScheduleCore = (word, rcon) =&gt; xorFirstByte(subWord(rotWord(word)), rcon)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Função auxiliar que devolve as últimas words. A ideia aqui é pegar a primeira word da última chave</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> lastWord = (arr) =&gt; arr.slice(-WORD_SIZE)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="gerao-das-chaves">Geração das chaves</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Separei nessa função, o procedimento de criar uma chave completa de 128 bits
a partir de uma chave anterior e um valor de rcon.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> generate = (key, rcon) =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Primeiramente calculo o valor base usando KeyScheduleCore que vai receber a última word da chave.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> base = keyScheduleCore(lastWord(key), rcon)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>divido a chave em grupos formando 4 words.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> words = group(key, WORDS_IN_A_KEY)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Então faço um reduce em cima dessas words, ou seja, um loop de 4 iterações.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">return</span> words.reduce( (k, word) =&gt; (</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Em cada iteração ele monta mais uma word da chave
A primeira word é um xor com a primeira word da chave anterior e o valor base
As words seguintes é um xor com a word correspondente na chave anterior
e a última word calculado da própria chave (estou usando <code>Uint8Array</code> pra armazenar os valores)</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([...k, ...xor(word, k.length ? lastWord(k) : base )])
  ), [])
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Finalmente a função de expansão de chave. Ela recebe uma chave e entrega 11!</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> key =&gt; (</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Passo um reduce sobre os RCONS, epara cada RCON executo a função de gerar chave
passando como entrada a última chave e o rcon da rodada</p></div></div><div class="code"><div class="wrapper">  RCON.reduce( (keys, rcon) =&gt; {
    <span class="hljs-keyword">const</span> [last] = [...keys].reverse()
    <span class="hljs-keyword">const</span> current = generate(last, rcon)

    <span class="hljs-keyword">return</span> [...keys, current]
  }, [<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(key)] )</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A chave original é entregue para o reducer como uma <code>Uint8Array</code></p></div></div><div class="code"><div class="wrapper">)</div></div></div></div></body></html>