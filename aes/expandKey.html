<!DOCTYPE html><html lang="en"><head><title>aes/expandKey</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="aes/expandKey"><meta name="groc-project-path" content="src/aes/expandKey.js"><meta name="groc-github-url" content="https://github.com/halan/aes-es6"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/halan/aes-es6/blob/master/src/aes/expandKey.js">src/aes/expandKey.js</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h2 id="expanso-das-chaves">Expansão das chaves</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="importaes">Importações</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Importa o passo <code>subBytes</code> que faz a substituição com a S-Box</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> { subBytes } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./rounds/subBytes'</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Importa xor, que recebe duas arrays de números e aplica um xor em cada elemento correspondente.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> {
  xor,
  reverse,
  pipe,
  map,
  reduce,
  flat,
  lastWord,
  chainBlocks,
  splitInWords
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../utils'</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="constante-rcon">Constante Rcon</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Constante rcon para ser feito xor com o primeiro byte e cada word (1 word são 4 bytes)
1 rcon para cada nova chave criada, ou seja: 10 rcons.
Mais detalhes sobre o cálculo para chegar nessa constante pode ser encontrado
<a href="https://en.wikipedia.org/wiki/Rijndael_key_schedule#Rcon">aqui</a>.
O rcon[0] não é utilizado no AES.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> RCON =
  [<span class="hljs-number">0x8d</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x1b</span>, <span class="hljs-number">0x36</span>]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="-keyschedulecore-"><code>KeyScheduleCore</code></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Esta função rotaciona os bytes de um word, ex:
<code>[0, 1, 2, 3] -&gt; [1, 2, 3, 0]</code></p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> rotWord = ([first, ...rest]) =&gt;
  [...rest, first]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>subWord</code> é a mesma coisa que o <code>subBytes</code>. No caso da expansão de chave esse procedimento é feito
sobre uma word. Todo o procedimento de expansão de chave é baseado em words, que funcionam como</p>
<p>subblocos. Entretanto o <code>subBytes</code> é apenas uma substituição de um byte por outro, se aplico em 4 bytes
ou em 16 o procedimento em si não é alterado.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> subWord = subBytes</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Faz um xor no primeiro byte de uma word com rcon especificado.
Esse procedimento é feito exatamente 16 vezes, um para cada valor de rcon.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> xorFirstByte = value =&gt; ([first, ...rest]) =&gt;
  [ value ^ first, ...rest ]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Primeiramente calculo o valor base usando <code>KeySchedule</code> que vai receber um rcon e a última word da chave.
Procedimento principal da expansão de chave. Aqui aplicamos a sequência:
<code>rotWord</code>, <code>subWord</code> e por fim o <code>xor</code> no <code>rcon</code> correspondente da rodada.
Esse procedimento é aplicado sempre na primeira word de cada chave, ou seja
é aplicada tantas vezes iguais ao número de rodadas, que no nosso caso são 11.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> keySchedule = rcon =&gt;
  pipe(
    lastWord,
    rotWord,
    subWord,
    xorFirstByte(rcon)
  )</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><a href="https://en.wikipedia.org/wiki/Rijndael_key_schedule#Common_operations">Mais detalhes...</a></p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="gerao-das-chaves">Geração das chaves</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Separei nessa função, o procedimento de criar uma chave completa de 128 bits
a partir de um valor base (keySchedule sobre o rcon correspondente) e a chave anterior.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> generate = (initial, key) =&gt;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Divido a chave em grupos formando 4 words.
Então faço um reduce em cima dessas words, ou seja, um loop de 4 iterações.
Em cada iteração ele monta mais uma word da chave
A primeira word é um xor com a primeira word da chave anterior e o valor base
As words seguintes é um xor com a word correspondente na chave anterior
e a última word calculado da própria chave.</p></div></div><div class="code"><div class="wrapper">  pipe(
    splitInWords,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>O chainBlocks aplicará um xor entre initial e o primeiro valor do array de words
O resultado passará por um xor com o segundo valor e assim por diante</p></div></div><div class="code"><div class="wrapper">    chainBlocks(xor)(initial),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>O flat irá desfazer o splitInWords, ao invés de ter 4 elementos com 4 bytes cada, teremos 16 bytes</p></div></div><div class="code"><div class="wrapper">    flat
  )(key)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Finalmente a função de expansão de chave. Ela recebe uma chave e entrega 11!</p></div></div><div class="code"><div class="wrapper"><span class="hljs-built_in">module</span>.exports = key =&gt;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Passo um reduce sobre os RCONS, e para cada RCON executo a função de geração de chave
passando como entrada a última chave e o rcon da rodada.</p></div></div><div class="code"><div class="wrapper">  pipe(</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Prepara uma coleção de keySchedule já com rcon correspondente aplicado</p></div></div><div class="code"><div class="wrapper">    map(keySchedule),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Passa um chainBlocks sobre o keySchedule já cm o rcon correspondente aplicado,</p></div></div><div class="code"><div class="wrapper">    chainBlocks(keyScheduleRcon =&gt; k =&gt;
      <span class="hljs-comment">//e então utiiza este valor como sendo o initial da função de geração de chaves</span>
      generate(keyScheduleRcon(k), k)
    )(key),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A chave inicial precisa estar contida na lista final</p></div></div><div class="code"><div class="wrapper">    keys =&gt; [key, ...keys],</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cada chave é cnvertida para um buffer</p></div></div><div class="code"><div class="wrapper">    map(Buffer.from)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>O rcon[0] não é utilizado, por isso o <code>slice</code>.</p></div></div><div class="code"><div class="wrapper">  )(RCON.slice(<span class="hljs-number">1</span>))</div></div></div></div></body></html>